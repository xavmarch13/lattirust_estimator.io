<!DOCTYPE html>
<html lang="en-us" dir="ltr">
<head><script src="/lattirust_estimator.io/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=lattirust_estimator.io/livereload" data-no-instant defer></script>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="
  Preliminaries
  #

This section is based on the following resources [1][2][3][4].">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="#343a40">
<meta name="color-scheme" content="light dark"><meta property="og:url" content="http://localhost:1313/lattirust_estimator.io/docs/preliminaries/">
  <meta property="og:site_name" content="Lattirust estimator 0.1">
  <meta property="og:title" content="Preliminaries">
  <meta property="og:description" content="Preliminaries # This section is based on the following resources [1][2][3][4].">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="website">
<title>Preliminaries | Lattirust estimator 0.1</title>
<link rel="icon" href="/lattirust_estimator.io/favicon.png" >
<link rel="manifest" href="/lattirust_estimator.io/manifest.json">
<link rel="canonical" href="http://localhost:1313/lattirust_estimator.io/docs/preliminaries/">
<link rel="stylesheet" href="/lattirust_estimator.io/book.min.6c8b9d2a1fc95075ed7da46ca81060b39add8fff6741ac51259f768929281e2c.css" integrity="sha256-bIudKh/JUHXtfaRsqBBgs5rdj/9nQaxRJZ92iSkoHiw=" crossorigin="anonymous">
  <script defer src="/lattirust_estimator.io/fuse.min.js"></script>
  <script defer src="/lattirust_estimator.io/en.search.min.ab710d7184d1da92e9afe7f84b054dc9aa5f56c2674c8fba3136865ef46f391d.js" integrity="sha256-q3ENcYTR2pLpr&#43;f4SwVNyapfVsJnTI&#43;6MTaGXvRvOR0=" crossorigin="anonymous"></script>
<link rel="alternate" type="application/rss+xml" href="http://localhost:1313/lattirust_estimator.io/docs/preliminaries/index.xml" title="Lattirust estimator 0.1" />
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js"></script>

<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body);"></script>

<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
            delimiters: [
                {left: "$$", right: "$$", display: true},
                {left: "$", right: "$", display: false}
            ]
        });
    });
</script>


<link rel="stylesheet" type="text/css" href="http://localhost:1313/lattirust_estimator.io/scss/hugo-simplecite.min.138dd14c6aaf1b1a9b55c4fe22f82166812ce8081413d67a3b464e411d2b63ef.css">
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/lattirust_estimator.io/"><span>Lattirust estimator 0.1</span>
  </a>
</h2>


<div class="book-search hidden">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>
<script>document.querySelector(".book-search").classList.remove("hidden")</script>















  
  <ul>
    
      
        <li class="book-section-flat" >
          
  
  

  
    <a href="/lattirust_estimator.io/docs/introduction/" class="">Introduction</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <a href="/lattirust_estimator.io/docs/preliminaries/" class="active">Preliminaries</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <a href="/lattirust_estimator.io/docs/cost-models/" class="">Cost Models</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <a href="/lattirust_estimator.io/docs/lattice-reduction/" class="">Lattice reduction</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <a href="/lattirust_estimator.io/docs/sis/" class="">SIS</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <a href="/lattirust_estimator.io/docs/rsis-msis/" class="">Module SIS and Ring SIS</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <a href="/lattirust_estimator.io/docs/sis-variants/" class="">SIS variants</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <a href="/lattirust_estimator.io/docs/estimator-options/" class="">Estimator options and API</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
  </ul>














</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/lattirust_estimator.io/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <h3>Preliminaries</h3>

  <label for="toc-control">
    
    <img src="/lattirust_estimator.io/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#lattices">Lattices</a>
      <ul>
        <li><a href="#volume-of-a-lattice">Volume of a Lattice</a></li>
        <li><a href="#dual-of-a-lattice">Dual of a Lattice</a></li>
        <li><a href="#minima-of-a-lattice-and-root-hermite-factor">Minima of a Lattice and Root Hermite Factor</a></li>
        <li><a href="#random-lattices-and-gaussian-heuristic">Random Lattices and Gaussian Heuristic</a></li>
      </ul>
    </li>
    <li><a href="#hard-problems-in-lattices">Hard Problems in Lattices</a></li>
    <li><a href="#summary-table-of-lattice-problems">Summary Table of Lattice Problems</a></li>
    <li><a href="#security">Security</a></li>
    <li><a href="#norms">Norms</a>
      <ul>
        <li></li>
      </ul>
    </li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown book-article"><h1 id="preliminaries">
  Preliminaries
  <a class="anchor" href="#preliminaries">#</a>
</h1>
<p>This section is based on the following resources [<a id="cite-1" class="hugo-simplecite-cite-hyperlink" href="#bibreference-1" title="N. Gama and P. Nguyen, Predicting lattice reduction, In Proc. Advances in cryptology–EUROCRYPT 2008: 27th annual international conference on the theory and applications of cryptographic techniques, istanbul, turkey, april 13-17, 2008. Proceedings 27, 2008, pp. 31–51. ">1</a>][<a id="cite-2" class="hugo-simplecite-cite-hyperlink" href="#bibreference-2" title="D. Micciancio and S. Goldwasser, Complexity of lattice problems: A cryptographic perspective. Springer Science &amp; Business Media, 2002. ">2</a>][<a id="cite-3" class="hugo-simplecite-cite-hyperlink" href="#bibreference-3" title="D. Micciancio and O. Regev, Lattice-based cryptography, in Post-quantum cryptography, Springer, 2009, pp. 147–191.">3</a>][<a id="cite-4" class="hugo-simplecite-cite-hyperlink" href="#bibreference-4" title="P. Nguyen, Hermite’s constant and lattice algorithms, in The LLL algorithm: Survey and applications, Springer, 2009, pp. 19–69.">4</a>].</p>
<h2 id="lattices">
  Lattices
  <a class="anchor" href="#lattices">#</a>
</h2>
<p>A <em>lattice</em> is defined as a discrete subgroup in $n$-dimensional $\mathbb{R}^n$ space with a periodic structure. It can be represented by a set of linearly independent vectors, commonly referred to as the basis of the lattice. If $\bold{b_1}, &hellip;, \bold{b_d}$ denote basis vectors, we can describe a lattice as:</p>
$$
\Lambda(\bold{b_1}, ..., \bold{b_d}) = \left\{\sum_{i=1}^{d} x_i \bold{b_i} : x_i \in \mathbb{Z} \right\}
$$<p>This represents the set of all linear combinations of the basis vectors. Here, $d$ is the dimension of the lattice in $\mathbb{R}^n$.</p>
<figure style="text-align: center; margin: 1em auto; max-width: 100%;">
    <img src="lattices-1.png" alt="Lattice grid 2D" style="max-width: 100%; height: auto; border: 1px solid #ddd; padding: 4px;">
    
        
            <figcaption style="font-size: 0.9em; margin-top: 0.5em; font-style: italic; text-align: center; color: #555;">
                A lattice in 2D
            </figcaption>
        
    
</figure>
<p>A lattice has many possible bases, but some are more useful than others. The goal of lattice reduction, as presented in later sections, is to find a qualitatively good basis composed of short and nearly orthogonal vectors.</p>
<p>In this work, we will specifically focus on $q$-ary lattices described by a basis $\bold{B}$, where the coefficients are taken modulo $q$. The membership of a vector to the lattice is determined by $\bold{x} \pmod{q}$.</p>
<h3 id="volume-of-a-lattice">
  Volume of a Lattice
  <a class="anchor" href="#volume-of-a-lattice">#</a>
</h3>
<p>In each lattice, we can define the volume of the lattice as the volume of its fundamental parallelepiped (the region enclosed by the basis vectors). This quantity is an <em>invariant</em> of the lattice and does not depend on the chosen basis. This means that applying Gram-Schmidt orthogonalization to any basis will yield an orthogonal basis from which we can approximate the volume of the lattice as:</p>
$$
\text{Vol}(\Lambda) =  \prod_{i=1}^{d} \lVert \bold{b_i}^* \rVert 
$$<p>where $\bold{b_i}^*$ are the orthogonal Gram-Schmidt vectors. It is also important to note that $\text{Vol}(\Lambda) = |\text{Det}(\bold{B})|$, where $\bold{B}$ is the basis matrix.</p>
<figure style="text-align: center; margin: 1em auto; max-width: 100%;">
    <img src="volume.png" alt="Volume of a lattice 2D" style="max-width: 100%; height: auto; border: 1px solid #ddd; padding: 4px;">
    
        
            <figcaption style="font-size: 0.9em; margin-top: 0.5em; font-style: italic; text-align: center; color: #555;">
                A lattice volume in 2D
            </figcaption>
        
    
</figure>
<p>This invariant is conceptually significant because it demonstrates that not all basis vectors can be small simultaneously.</p>
<h3 id="dual-of-a-lattice">
  Dual of a Lattice
  <a class="anchor" href="#dual-of-a-lattice">#</a>
</h3>
<p>The dual of a lattice $\Lambda$ in $\mathbb{R}^d$ is denoted $\Lambda^*$ and is defined as the lattice composed of vectors $\bold{y}$ such that:</p>
$$
\langle \bold{x}, \bold{y} \rangle \in \mathbb{Z}, \forall \bold{x} \in \Lambda
$$<p>For any lattice described by basis $\bold{B}$, we have:</p>
$$
\Lambda(\bold{B})^* = \Lambda((\bold{B}^{-1})^T) \quad \text{and} \quad \text{Vol}(\Lambda^*) = \frac{1}{\text{Vol}(\Lambda)}
$$<h3 id="minima-of-a-lattice-and-root-hermite-factor">
  Minima of a Lattice and Root Hermite Factor
  <a class="anchor" href="#minima-of-a-lattice-and-root-hermite-factor">#</a>
</h3>
<p>We denote by $\lambda_i(\bold{B})$ the $i$-th minimum of a lattice described by a basis $\bold{B}$. Note that for the remainder of this work, we may interchangeably use $\lambda_i(\bold{B})$, $\lambda_i(\Lambda(\bold{B}))$, or $\lambda_i(\Lambda)$ for minima and other related measures. Intuitively, $\lambda_i(\bold{B})$ represents the radius of the smallest zero-centered ball containing at least $i$ linearly independent lattice vectors.</p>
<p>The root Hermite constant $\gamma_n$ is a constant that determines how short a lattice element can be. It is known exactly only for $n \in {1, 2, 3, 4, 5, 6, 7, 8, 24}$, but upper bounds for other values are available and can be found in [<a id="cite-5" class="hugo-simplecite-cite-hyperlink" href="#bibreference-5" title="H. Cohn and N. Elkies, New upper bounds on sphere packings i, Annals of mathematics, pp. 689–714, 2003. ">5</a>]. In general, determining $\lambda_i(\bold{B})$ is difficult, so we often refer to upper bounds.</p>
<p><strong>Minkowski&rsquo;s Second Theorem:</strong> For any lattice in $\mathbb{R}^n$ and any $1 \leq d \leq n$, we have:</p>
$$
\left( \prod_{i=1}^{d} \lambda_i(\Lambda) \right)^{\frac{1}{d}} \leq \sqrt{\gamma_n} \cdot \text{Vol}(\Lambda)^{\frac{1}{n}}
$$<p>Formally, the Hermite constant for a full-rank lattice in $\mathbb{R}^n$ is defined as:</p>
$$
\gamma_n = \sup_{\Lambda \subset \mathbb{R}^n} \frac{\lambda_1^2(\Lambda)}{\det(\Lambda)^{2/n}}
$$<p>The Hermite constant $\gamma_n$ is closely related to the root Hermite factor $\delta_n$, which we will describe in more detail in the lattice reduction chapter. The root Hermite factor is used to evaluate the quality of a basis, and we have $\delta_n = \sqrt{\gamma_n}$.</p>
<h3 id="random-lattices-and-gaussian-heuristic">
  Random Lattices and Gaussian Heuristic
  <a class="anchor" href="#random-lattices-and-gaussian-heuristic">#</a>
</h3>
<p>The notion of a random lattice is mathematically complex (see Haar measures). As a simplifying assumption, imagine such a lattice being sampled from an existing random distribution that adheres, with overwhelming probability, to the Gaussian heuristic described below.</p>
$$
\frac{\lambda_i(\Lambda)}{\text{Vol}(\Lambda)^{1/n}} \approx \frac{\Gamma\left(1 + \frac{n}{2}\right)^{1/n}}{\sqrt{\pi}} \approx \sqrt{\frac{n}{2\pi e}}
$$<p>The Gaussian heuristic predicts that the number of lattice points inside any measurable body $\mathcal{B} \subset \mathbb{R}^d$ is approximately $\frac{\text{Vol}(\mathcal{B})}{\text{Vol}(\Lambda)}$. Applied to a Euclidean $d$-ball, this implies that the length of the first vector is approximately:</p>
$$
\lambda_1(\Lambda) \approx \left(\frac{\text{Vol}(\mathcal{B})}{\text{Vol}(\Lambda)}\right)^{\frac{1}{d}} \approx \sqrt{\frac{d}{2\pi e}} \cdot \text{Vol}(\Lambda)^{\frac{1}{d}}
$$<h2 id="hard-problems-in-lattices">
  Hard Problems in Lattices
  <a class="anchor" href="#hard-problems-in-lattices">#</a>
</h2>
<p>The security of lattice-based constructions relies on several variants of related problems. The foundation of this security is based on the fact that finding a short non-zero vector in a lattice is computationally hard. Below are the definitions of the key problems:</p>
<ol>
<li>
<p><strong>Shortest Vector Problem (SVP)</strong></p>
<p><strong>Definition:</strong><br>
Given a lattice $\Lambda$ with basis $\bold{B}$, the <strong>Shortest Vector Problem (SVP)</strong> is the problem of finding a non-zero vector $\bold{v} \in \Lambda$ such that:</p>
$$
    \|\bold{v}\| = \lambda_1(\Lambda)
    $$<p>where $\lambda_1(\Lambda)$ is the length of the shortest non-zero vector in the lattice. This is a well-known NP-hard problem in the worst case, and its approximation remains challenging for cryptographic settings.</p>
</li>
<li>
<p><strong>Hermite Shortest Vector Problem (H-SVP)</strong></p>
<p><strong>Definition:</strong><br>
The <strong>Hermite Shortest Vector Problem (H-SVP)</strong> is a scaled version of the SVP. It asks for a non-zero vector $\bold{v} \in \Lambda$ such that:</p>
$$
    \|\bold{v}\| \leq \delta_n \cdot \text{Vol}(\Lambda)^{1/n}
    $$<p>where $\delta_n$ is the root Hermite factor. Unlike exact SVP, H-SVP allows finding a vector that is &ldquo;short enough&rdquo; relative to the lattice volume. H-SVP is easier to approximate than SVP and is central to lattice reduction algorithms like LLL and BKZ.</p>
</li>
<li>
<p><strong>Approximate Shortest Vector Problem (Approx-SVP)</strong></p>
<p><strong>Definition:</strong><br>
The <strong>Approximate Shortest Vector Problem (Approx-SVP)</strong> generalizes SVP by relaxing the requirement to find the exact shortest vector. Given a lattice $\Lambda$ and an approximation factor $\gamma \geq 1$, the goal is to find a non-zero vector $\bold{v} \in \Lambda$ such that:</p>
$$
    \|\bold{v}\| \leq \gamma \cdot \lambda_1(\Lambda)
    $$<p>For sufficiently large $\gamma$, Approx-SVP becomes computationally easier, but it remains hard for small $\gamma$, especially in high-dimensional lattices.</p>
</li>
<li>
<p><strong>Unique Shortest Vector Problem (Unique-SVP)</strong></p>
<p><strong>Definition:</strong><br>
The <strong>Unique Shortest Vector Problem (Unique-SVP)</strong> is a variant of SVP where the shortest vector is guaranteed to be significantly shorter than all other lattice vectors. Specifically, there exists a gap $\beta &gt; 1$ such that:</p>
$$
    \lambda_2(\Lambda) \geq \beta \cdot \lambda_1(\Lambda)
    $$<p>where $\lambda_2(\Lambda)$ is the length of the second shortest lattice vector. The task is to find the unique shortest vector $\bold{v} \in \Lambda$. This problem is somewhat easier than general SVP due to the presence of a unique solution, but it still remains computationally challenging.</p>
</li>
<li>
<p><strong>Closest Vector Problem (CVP)</strong></p>
<p><strong>Definition:</strong><br>
Given a lattice $\Lambda$ with basis $\bold{B}$ and a target vector $\bold{t} \in \mathbb{R}^n$, the <strong>Closest Vector Problem (CVP)</strong> is the problem of finding a vector $\bold{v} \in \Lambda$ such that:</p>
$$
    \|\bold{t} - \bold{v}\| = \min_{\bold{w} \in \Lambda} \|\bold{t} - \bold{w}\|
    $$<p>CVP is generally harder than SVP and is also NP-hard in the worst case. Approximation versions of CVP, such as $\gamma$-CVP (finding $\bold{v}$ within a $\gamma$-factor of the closest vector), are frequently studied in lattice cryptography.</p>
</li>
<li>
<p><strong>Shortest Independent Vector Problem (SIVP)</strong></p>
<p><strong>Definition:</strong><br>
The <strong>Shortest Independent Vector Problem (SIVP)</strong> involves finding $n$ linearly independent vectors ${\bold{v}_1, \bold{v}_2, \dots, \bold{v}_n}$ in a lattice $\Lambda$ such that the maximum norm of the vectors is minimized:</p>
$$
    \max_{i=1}^n \|\bold{v}_i\| = \lambda_n(\Lambda)
    $$<p>where $\lambda_n(\Lambda)$ represents the length of the $n$-th successive minimum of the lattice. SIVP is closely related to the geometry of the lattice and remains computationally hard. It is used in cryptographic constructions and reduction proofs, often connecting the hardness of lattice problems to cryptographic assumptions.</p>
</li>
</ol>
<h2 id="summary-table-of-lattice-problems">
  Summary Table of Lattice Problems
  <a class="anchor" href="#summary-table-of-lattice-problems">#</a>
</h2>
<table>
  <thead>
      <tr>
          <th><strong>Problem</strong></th>
          <th><strong>Goal</strong></th>
          <th><strong>Output</strong></th>
          <th><strong>Difficulty</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>(I)SVP</strong></td>
          <td>Find the shortest vector</td>
          <td>$\bold{v} \in \Lambda, |\bold{v}| = \lambda_1$</td>
          <td>NP-hard in the worst case</td>
      </tr>
      <tr>
          <td><strong>H-SVP</strong></td>
          <td>Find a short enough vector</td>
          <td>$\bold{v} \in \Lambda, |\bold{v}| \leq \delta_n \cdot \text{Vol}(\Lambda)^{1/n}$</td>
          <td>Easier than SVP, used in reduction</td>
      </tr>
      <tr>
          <td><strong>Approx-(I)SVP</strong></td>
          <td>Approximate the shortest vector</td>
          <td>$\bold{v} \in \Lambda, |\bold{v}| \leq \gamma \lambda_1$</td>
          <td>Hard for small $\gamma$</td>
      </tr>
      <tr>
          <td><strong>Unique-(I)SVP</strong></td>
          <td>Find the unique shortest vector</td>
          <td>$\bold{v} \in \Lambda, \lambda_2 \geq \beta \lambda_1$</td>
          <td>Easier than SVP (gap $\beta$)</td>
      </tr>
      <tr>
          <td><strong>CVP</strong></td>
          <td>Find the closest lattice vector to target</td>
          <td>$\bold{v} \in \Lambda, |\bold{t} - \bold{v}|$</td>
          <td>NP-hard, harder than SVP</td>
      </tr>
  </tbody>
</table>
<p>Importantly, for later sections, note that any algorithm solving Approx-SVP with factor $\alpha$ also solves Hermite-SVP for factor $\alpha\sqrt{\gamma_n}$ in polynomial time. Additionally, any algorithm solving H-SVP with factor $\alpha$ can be used a linear number of times to solve Approx-SVP with factor $\alpha^2$ in polynomial time [<a id="cite-6" class="hugo-simplecite-cite-hyperlink" href="#bibreference-6" title="L. Lovász, An algorithmic theory of numbers, graphs and convexity. SIAM, 1986. ">6</a>]. There also exist reductions from worst-case Approx-SVP to average-case H-SVP for certain classes of lattices.</p>
<h2 id="security">
  Security
  <a class="anchor" href="#security">#</a>
</h2>
<p>The foundational belief in the security of new lattice-based primitives stems from a key result: Ajtai’s theorem, which connected the hardness of certain average-case problems to the difficulty of worst-case problems in lattices [<a id="cite-7" class="hugo-simplecite-cite-hyperlink" href="#bibreference-7" title="M. Ajtai, Generating hard instances of lattice problems, In Proc. Proceedings of the twenty-eighth annual ACM symposium on theory of computing, 1996, pp. 99–108. ">7</a>]. Specifically, Ajtai demonstrated that for the Short Integer Solution (SIS) problem—which we will define later—the average-case instances are at least as hard as the worst-case instances of the Shortest Vector Problem (SVP) on lattices. This implies that if one could efficiently solve random instances of SIS, they could also solve the worst-case SVP, a problem believed to be intractable even for quantum computers. Ajtai’s theorem provides a strong security guarantee for lattice-based cryptographic schemes by grounding their security in the hardness of well-studied lattice problems like SVP.</p>
<p>The security assumptions based on the hardness of SVP can be summarized by two conjectures from [<a id="cite-3" class="hugo-simplecite-cite-hyperlink" href="#bibreference-3" title="D. Micciancio and O. Regev, Lattice-based cryptography, in Post-quantum cryptography, Springer, 2009, pp. 147–191.">3</a>]:</p>
<ol>
<li>There is no polynomial-time algorithm that approximates lattice problems to within polynomial factors.</li>
<li>There is no polynomial-time quantum algorithm that approximates lattice problems within polynomial factors.</li>
</ol>
<p>These conjectures underpin the belief that lattice-based cryptosystems remain secure even in the presence of quantum adversaries, making them promising candidates for post-quantum security.</p>
<h2 id="norms">
  Norms
  <a class="anchor" href="#norms">#</a>
</h2>
<p>We provide a brief overview of norms that will be used later and their relationships. We also introduce norms for elements in modules and rings.</p>
<h4 id="definition-of--ell_p--norms">
  Definition of \( \ell_p \)-Norms
  <a class="anchor" href="#definition-of--ell_p--norms">#</a>
</h4>
<p>For a vector $\boldsymbol{f} \in \mathbb{R}^n$, the $\ell_p$-norms are defined as follows:</p>
$$
\|\boldsymbol{f}\|_1 = \sum_{i=1}^n |f_i|, \quad
\|\boldsymbol{f}\|_2 = \sqrt{\sum_{i=1}^n f_i^2}, \quad
\|\boldsymbol{f}\|_p = \left(\sum_{i=1}^n |f_i|^p\right)^{1/p}, \quad
\|\boldsymbol{f}\|_\infty = \max_{i} |f_i|.
$$<p>These norms generalize to module elements $\boldsymbol{f} \in R_q^m$ (where $R_q$ is a quotient ring, e.g., $\mathbb{Z}_q[x]/\langle x^n + 1 \rangle$), by viewing them as $m \cdot n$-dimensional vectors [<a id="cite-8" class="hugo-simplecite-cite-hyperlink" href="#bibreference-8" title="C. Baum, I. Damgård, V. Lyubashevsky, S. Oechsner, and C. Peikert, More efficient commitments from structured lattice assumptions, In Proc. International conference on security and cryptography for networks, 2018, pp. 368–385. ">8</a>]. Note that modules generalize rings, so a vector $\boldsymbol{f}$ in the ring $R_q^1$ is represented by a set of coefficients $f_i$ such that:</p>
$$
\boldsymbol{f} = \sum_i f_i x^i.
$$<h4 id="relationships-between-norms">
  Relationships Between Norms
  <a class="anchor" href="#relationships-between-norms">#</a>
</h4>
<p>For $p, q \geq 1$ with $p \leq q$, the following relationships hold for $\boldsymbol{f} \in \mathbb{R}^n$:</p>
$$
\|\boldsymbol{f}\|_\infty \leq \|\boldsymbol{f}\|_q \leq \|\boldsymbol{f}\|_p \leq \|\boldsymbol{f}\|_1.
$$<p>This inequality indicates that the $\ell_\infty$-norm is always the smallest, while the $\ell_1$-norm is the largest.</p>
<h4 id="applications-in-lattice-problem-hardness-estimation">
  Applications in Lattice Problem Hardness Estimation
  <a class="anchor" href="#applications-in-lattice-problem-hardness-estimation">#</a>
</h4>
<p>Norms are crucial for bounding errors and ensuring security in lattice-based cryptography. For example:</p>
<ul>
<li>In the <strong>Learning with Errors (LWE)</strong> problem, the $\ell_2$-norm is used to bound the error vector.</li>
<li>In the <strong>Short Integer Solution (SIS)</strong> problem, the $\ell_\infty$-norm is often employed to restrict the coefficients of the solution.</li>
</ul>
<p>By carefully analyzing and relating these norms, cryptographic schemes ensure robustness against attacks while maintaining efficiency.</p>
<h1 id="references">
  References
  <a class="anchor" href="#references">#</a>
</h1>
<ol class="hugo-simplecite-reference-list"><li class="hugo-simplecite-reference-list-item" id="bibreference-1">N. Gama and&#32;P. Nguyen,&#32;<q>Predicting lattice reduction,</q>&#32;In Proc. Advances in cryptology–EUROCRYPT 2008: 27th annual international conference on the theory and applications of cryptographic techniques, istanbul, turkey, april 13-17, 2008. Proceedings 27,&#32;2008, pp. 31–51.&#32;<a href="#cite-1" class="back-arrow" title="Back to text">↩</a></li><li class="hugo-simplecite-reference-list-item" id="bibreference-2">D. Micciancio and&#32;S. Goldwasser,&#32;<em>Complexity of lattice problems: A cryptographic perspective</em>.&#32;Springer Science &amp; Business Media, 2002.&#32;<a href="#cite-2" class="back-arrow" title="Back to text">↩</a></li><li class="hugo-simplecite-reference-list-item" id="bibreference-3">D. Micciancio and&#32;O. Regev,&#32;<q>Lattice-based cryptography,</q>&#32;in <em>Post-quantum cryptography</em>,&#32;Springer, 2009, pp. 147–191.<a href="#cite-3" class="back-arrow" title="Back to text">↩</a></li><li class="hugo-simplecite-reference-list-item" id="bibreference-4">P. Nguyen,&#32;<q>Hermite’s constant and lattice algorithms,</q>&#32;in <em>The LLL algorithm: Survey and applications</em>,&#32;Springer, 2009, pp. 19–69.<a href="#cite-4" class="back-arrow" title="Back to text">↩</a></li><li class="hugo-simplecite-reference-list-item" id="bibreference-5">H. Cohn and&#32;N. Elkies,&#32;<q>New upper bounds on sphere packings i,</q>&#32;<em>Annals of mathematics</em>,&#32;pp. 689–714,&#32;2003.&#32;<a href="#cite-5" class="back-arrow" title="Back to text">↩</a></li><li class="hugo-simplecite-reference-list-item" id="bibreference-6">L. Lovász,&#32;<em>An algorithmic theory of numbers, graphs and convexity</em>.&#32;SIAM, 1986.&#32;<a href="#cite-6" class="back-arrow" title="Back to text">↩</a></li><li class="hugo-simplecite-reference-list-item" id="bibreference-7">M. Ajtai,&#32;<q>Generating hard instances of lattice problems,</q>&#32;In Proc. Proceedings of the twenty-eighth annual ACM symposium on theory of computing,&#32;1996, pp. 99–108.&#32;<a href="#cite-7" class="back-arrow" title="Back to text">↩</a></li><li class="hugo-simplecite-reference-list-item" id="bibreference-8">C. Baum,&#32;I. Damgård,&#32;V. Lyubashevsky,&#32;S. Oechsner, and&#32;C. Peikert,&#32;<q>More efficient commitments from structured lattice assumptions,</q>&#32;In Proc. International conference on security and cryptography for networks,&#32;2018, pp. 368–385.&#32;<a href="#cite-8" class="back-arrow" title="Back to text">↩</a></li></ol>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





</div>



  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#lattices">Lattices</a>
      <ul>
        <li><a href="#volume-of-a-lattice">Volume of a Lattice</a></li>
        <li><a href="#dual-of-a-lattice">Dual of a Lattice</a></li>
        <li><a href="#minima-of-a-lattice-and-root-hermite-factor">Minima of a Lattice and Root Hermite Factor</a></li>
        <li><a href="#random-lattices-and-gaussian-heuristic">Random Lattices and Gaussian Heuristic</a></li>
      </ul>
    </li>
    <li><a href="#hard-problems-in-lattices">Hard Problems in Lattices</a></li>
    <li><a href="#summary-table-of-lattice-problems">Summary Table of Lattice Problems</a></li>
    <li><a href="#security">Security</a></li>
    <li><a href="#norms">Norms</a>
      <ul>
        <li></li>
      </ul>
    </li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












